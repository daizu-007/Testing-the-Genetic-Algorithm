<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>遺伝的アルゴリズム画像生成器 (64x64)</title>
    <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const IMAGE_SIZE = 64;
        const MUTATION_RATE = 0.05;
        const CROSSOVER_RATE = 0.7;

        const ImageGenerator = () => {
            const [images, setImages] = React.useState([]);
            const [generation, setGeneration] = React.useState(0);
            const [referenceImage, setReferenceImage] = React.useState(null);
            const [autoMode, setAutoMode] = React.useState(false);
            const [showSettings, setShowSettings] = React.useState(false);
            const [settings, setSettings] = React.useState({
                populationSize: 9,
                mutationRate: MUTATION_RATE,
                crossoverRate: CROSSOVER_RATE,
            });

            const canvasRefs = React.useRef([]);

            React.useEffect(() => {
                generateInitialImages();
            }, []);

            React.useEffect(() => {
                let isRunning = false;

                const runAutoMode = async () => {
                    if (isRunning || !autoMode || !referenceImage) return;

                    isRunning = true;
                    try {
                        const [parent1Index, parent2Index] = await findBestPair();
                        await handleImageSelect(parent1Index, parent2Index);
                        
                        if (autoMode) {
                            setTimeout(runAutoMode, 0);
                        }
                    } finally {
                        isRunning = false;
                    }
                };

                if (autoMode && referenceImage) {
                    runAutoMode();
                }

                return () => {
                    isRunning = false;
                };
            }, [autoMode, referenceImage, images]);

            const generateInitialImages = () => {
                const newImages = Array(settings.populationSize).fill().map(() => generateRandomImageData());
                setImages(newImages);
                setGeneration(0);
            };

            const generateRandomImageData = () => {
                const imageData = new ImageData(IMAGE_SIZE, IMAGE_SIZE);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    imageData.data[i] = Math.floor(Math.random() * 256);
                    imageData.data[i + 1] = Math.floor(Math.random() * 256);
                    imageData.data[i + 2] = Math.floor(Math.random() * 256);
                    imageData.data[i + 3] = 255;
                }
                return imageData;
            };

            const mutateImageData = (baseImageData) => {
                const newImageData = new ImageData(
                    new Uint8ClampedArray(baseImageData.data),
                    IMAGE_SIZE,
                    IMAGE_SIZE
                );

                for (let i = 0; i < newImageData.data.length; i += 4) {
                    if (Math.random() < settings.mutationRate) {
                        newImageData.data[i] = Math.floor(Math.random() * 256);
                        newImageData.data[i + 1] = Math.floor(Math.random() * 256);
                        newImageData.data[i + 2] = Math.floor(Math.random() * 256);
                    }
                }

                return newImageData;
            };

            const crossoverImageData = (parent1Data, parent2Data) => {
                const childData = new ImageData(IMAGE_SIZE, IMAGE_SIZE);
                const crossoverPoint = Math.floor(Math.random() * parent1Data.data.length);

                for (let i = 0; i < childData.data.length; i += 4) {
                    if (i < crossoverPoint || Math.random() > settings.crossoverRate) {
                        childData.data[i] = parent1Data.data[i];
                        childData.data[i + 1] = parent1Data.data[i + 1];
                        childData.data[i + 2] = parent1Data.data[i + 2];
                    } else {
                        childData.data[i] = parent2Data.data[i];
                        childData.data[i + 1] = parent2Data.data[i + 1];
                        childData.data[i + 2] = parent2Data.data[i + 2];
                    }
                    childData.data[i + 3] = 255;
                }

                return childData;
            };

            const handleImageSelect = async (index1, index2) => {
                const parent1 = images[index1];
                const parent2 = images[index2];
                const child = crossoverImageData(parent1, parent2);
                const mutatedChild = mutateImageData(child);

                const newImages = [...images];
                newImages[index1] = mutatedChild;
                newImages[index2] = generateRandomImageData(); // 多様性維持のため

                setImages(newImages);
                setGeneration(prev => prev + 1);
            };

            const handleReferenceImageUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = IMAGE_SIZE;
                            canvas.height = IMAGE_SIZE;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, IMAGE_SIZE, IMAGE_SIZE);
                            setReferenceImage(ctx.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE));
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            const calculateImageSimilarity = React.useCallback((imageData1, imageData2) => {
                let diff = 0;
                for (let i = 0; i < imageData1.data.length; i += 4) {
                    diff += Math.abs(imageData1.data[i] - imageData2.data[i]);
                    diff += Math.abs(imageData1.data[i+1] - imageData2.data[i+1]);
                    diff += Math.abs(imageData1.data[i+2] - imageData2.data[i+2]);
                }
                return diff;
            }, []);

            const findBestPair = React.useCallback(async () => {
                if (!referenceImage) return [0, 1];

                const similarities = images.map(img => calculateImageSimilarity(referenceImage, img));
                const sortedIndices = similarities.map((_, i) => i).sort((a, b) => similarities[a] - similarities[b]);

                // 最も似ている画像と、ランダムに選んだ画像をペアにする
                return [sortedIndices[0], Math.floor(Math.random() * images.length)];
            }, [images, referenceImage, calculateImageSimilarity]);

            const renderImage = (imageData, index) => {
                const canvasRef = React.useRef(null);

                React.useEffect(() => {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    ctx.putImageData(imageData, 0, 0);
                }, [imageData]);

                return (
                    <canvas
                        ref={canvasRef}
                        width={IMAGE_SIZE}
                        height={IMAGE_SIZE}
                        className="w-32 h-32 cursor-pointer border-2 hover:border-blue-500"
                        style={{imageRendering: 'pixelated'}}
                        onClick={() => !autoMode && handleImageSelect(index, (index + 1) % images.length)}
                    />
                );
            };

            const handleSettingChange = (key, value) => {
                setSettings(prev => ({ ...prev, [key]: value }));
            };

            return (
                <div className="p-4">
                    <h1 className="text-2xl font-bold mb-4">遺伝的アルゴリズム画像生成器 (64x64)</h1>
                    <p className="mb-4">世代: {generation}</p>
                    <div className="grid grid-cols-3 gap-4 mb-4">
                        {images.map((image, index) => (
                            <div key={index}>
                                {renderImage(image, index)}
                            </div>
                        ))}
                    </div>
                    <div className="mb-4">
                        <input type="file" accept="image/*" onChange={handleReferenceImageUpload} className="mb-2" />
                        {referenceImage && (
                            <canvas
                                ref={el => {
                                    if (el) {
                                        el.getContext('2d').putImageData(referenceImage, 0, 0);
                                    }
                                }}
                                width={IMAGE_SIZE}
                                height={IMAGE_SIZE}
                                className="w-32 h-32 object-cover"
                                style={{imageRendering: 'pixelated'}}
                            />
                        )}
                    </div>
                    <div className="flex items-center space-x-2 mb-4">
                        <input
                            type="checkbox"
                            id="auto-mode"
                            checked={autoMode}
                            onChange={e => setAutoMode(e.target.checked)}
                        />
                        <label htmlFor="auto-mode">自動モード</label>
                    </div>
                    <button
                        className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mr-2"
                        onClick={generateInitialImages}
                        disabled={autoMode}
                    >
                        新しい画像セットを生成
                    </button>
                    <button
                        className="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded"
                        onClick={() => setShowSettings(!showSettings)}
                    >
                        {showSettings ? '設定を隠す' : '設定を表示'}
                    </button>
                    {showSettings && (
                        <div className="mt-4 p-4 border rounded">
                            <h2 className="text-xl font-bold mb-2">詳細設定</h2>
                            <div className="mb-2">
                                <label className="block">集団サイズ:</label>
                                <input
                                    type="number"
                                    value={settings.populationSize}
                                    onChange={e => handleSettingChange('populationSize', parseInt(e.target.value))}
                                    className="border rounded px-2 py-1"
                                    min="2"
                                    max="18"
                                />
                            </div>
                            <div className="mb-2">
                                <label className="block">突然変異率:</label>
                                <input
                                    type="number"
                                    value={settings.mutationRate}
                                    onChange={e => handleSettingChange('mutationRate', parseFloat(e.target.value))}
                                    className="border rounded px-2 py-1"
                                    step="0.01"
                                    min="0"
                                    max="1"
                                />
                            </div>
                            <div className="mb-2">
                                <label className="block">交叉率:</label>
                                <input
                                    type="number"
                                    value={settings.crossoverRate}
                                    onChange={e => handleSettingChange('crossoverRate', parseFloat(e.target.value))}
                                    className="border rounded px-2 py-1"
                                    step="0.01"
                                    min="0"
                                    max="1"
                                />
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<ImageGenerator />, document.getElementById('root'));
    </script>
</body>
</html>